use std::cmp::Ordering;
use std::fmt::Debug;

pub trait KeyValue {
    type K: Ord + Debug;
    type V;
    fn key(&self) -> &Self::K;
    fn value(&self) -> &Self::V;
}

// implementation of `KeyValue` for all combinations of tuple of integers
include!(concat!(env!("OUT_DIR"), "/lib.rs")); // generated by build.rs

#[derive(Clone, Debug)]
pub struct MapOfIndexes<T> {
    inner: Vec<T>,
}

#[derive(Clone, Debug)]
pub struct SortedMapOfIndexes<T> {
    inner: Vec<T>,
}

impl<T: KeyValue> MapOfIndexes<T> {
    pub fn new() -> Self {
        Self { inner: Vec::new() }
    }

    pub fn push(&mut self, element: T) {
        self.inner.push(element);
    }
}

impl<T: KeyValue> From<MapOfIndexes<T>> for SortedMapOfIndexes<T> {
    fn from(mut map_of_index: MapOfIndexes<T>) -> Self {
        map_of_index.inner.sort_by(|a, b| a.key().cmp(b.key()));
        Self {
            inner: map_of_index.inner,
        }
    }
}

impl<T: KeyValue> SortedMapOfIndexes<T> {
    pub fn new() -> Self {
        Self { inner: Vec::new() }
    }

    pub fn push(&mut self, element: T) {
        if let Some(last) = self.inner.last() {
            println!("{:?}", last.key());
            if last.key() >= element.key() {
                panic!(
                    "Attempted to push a lower element {:?}, last element value is: {:?}",
                    element.key(),
                    last.key()
                );
            }
        }
        self.inner.push(element)
    }

    pub fn get(&self, key: T::K) -> Option<&T::V> {
        let mut idx = self.inner.len() / 2;
        for _ in 0..std::mem::size_of::<T::K>() {
            match self.inner[idx].key().cmp(&key) {
                Ordering::Less => idx = std::cmp::min(idx * 2, self.inner.len() - 1),
                Ordering::Greater => idx /= 2,
                Ordering::Equal => return Some(self.inner[idx].value()),
            }
        }
        None
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_init() {
        MapOfIndexes::<(u8, u8)>::new();
    }

    #[test]
    fn test_push() {
        let mut s = MapOfIndexes::<(i128, u8)>::new();
        s.push((1, 1));
        s.push((2, 1));
        assert_eq!(&s.inner, &[(1, 1), (2, 1)]);
    }

    #[test]
    fn test_push_sorted() {
        let mut s = SortedMapOfIndexes::<(i128, u8)>::new();
        s.push((1, 1));
        s.push((2, 1));
        assert_eq!(&s.inner, &[(1, 1), (2, 1)]);
    }

    #[test]
    fn test_get() {
        let mut s = SortedMapOfIndexes::<(i128, u8)>::new();
        s.push((10, 10));
        s.push((11, 11));
        s.push((12, 12));
        s.push((13, 13));
        for i in 10..14 {
            assert_eq!(s.get(i as i128), Some(&(i as u8)));
        }
    }

    #[test]
    #[should_panic]
    fn test_push_sorted_panic() {
        let mut s = SortedMapOfIndexes::<(i128, u8)>::new();
        s.push((1, 1));
        s.push((-100, 1));
    }
}
